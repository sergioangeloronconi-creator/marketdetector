<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Detector - Grafici Anno per Anno | Q-Mentor</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        
        .chart-container {
            margin: 30px 0;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            font-size: 1.5em;
            color: #667eea;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        .table-container {
            margin: 30px 0;
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        
        td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }
        
        tr:hover {
            background: #f5f5f5;
        }
        
        .bull {
            background-color: rgba(76, 175, 80, 0.2) !important;
            color: #2e7d32;
            font-weight: bold;
        }
        
        .bear {
            background-color: rgba(244, 67, 54, 0.2) !important;
            color: #c62828;
            font-weight: bold;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
            color: #667eea;
        }
        
        .footer {
            background: #f8f9fa;
            padding: 20px;
            text-align: center;
            color: #666;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Market Detector - Grafici Anno per Anno</h1>
            <p>Q-Mentor Framework | Classificazione Bull/Bear</p>
        </div>
        
        <div class="content">
            <div class="info-box">
                <strong>üí° Istruzioni:</strong> Questo grafico mostra la classificazione Bull/Bear anno per anno basata su SMA150. 
                I dati vengono caricati da <strong>Financial Modeling Prep API</strong>. Se i grafici non si caricano, verifica la connessione internet e la validit√† della API key.
            </div>
            
            <div id="loading" class="loading">
                Caricamento dati SPY da Financial Modeling Prep API... ‚è≥<br>
                <small id="loadingStatus" style="color: #999; margin-top: 10px; display: block;"></small>
            </div>
            
            <div id="charts" style="display: none;">
                <div class="chart-container">
                    <div class="chart-title">1. SPY con Classificazione Bull/Bear (Background Colorato)</div>
                    <div id="chart1"></div>
                </div>
                
                <div class="chart-container">
                    <div class="chart-title">2. SPY vs SMA150 - Percentuale (Discriminante Principale)</div>
                    <div id="chart2"></div>
                </div>
                
                <div class="chart-container">
                    <div class="chart-title">3. Riepilogo Anno per Anno - % Giorni in Fase BULL</div>
                    <div id="chart3"></div>
                </div>
                
                <div class="table-container">
                    <div class="chart-title">Tabella Riepilogo Anno per Anno</div>
                    <table id="summaryTable">
                        <thead>
                            <tr>
                                <th>Anno</th>
                                <th>Fase Dominante</th>
                                <th>Media SPY vs SMA150</th>
                                <th>% Giorni BULL</th>
                                <th>Prezzo Inizio</th>
                                <th>Prezzo Fine</th>
                                <th>Variazione Anno</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="footer">
            <p>Market Detector - Q-Mentor Framework | Versione Ufficiale</p>
            <p>Logica: SMA150 come discriminante principale (BULL: SPY > SMA150, BEAR: SPY < SMA150)</p>
            <p>Dati forniti da <strong>Financial Modeling Prep API</strong></p>
        </div>
    </div>

    <script>
        // Funzione per calcolare variabili strutturali
        function calcolaVariabiliStrutturali(data) {
            const closes = data.map(d => d.close);
            const dates = data.map(d => new Date(d.date));
            
            // EMA30
            const ema30 = calculateEMA(closes, 30);
            
            // SMA150
            const sma150 = calculateSMA(closes, 150);
            
            // Calcolo posizioni relative
            const spy_vs_ema30 = closes.map((close, i) => 
                ema30[i] ? (close - ema30[i]) / ema30[i] : null
            );
            
            const spy_vs_sma150 = closes.map((close, i) => 
                sma150[i] ? (close - sma150[i]) / sma150[i] : null
            );
            
            return { ema30, sma150, spy_vs_ema30, spy_vs_sma150, dates, closes };
        }
        
        // Funzione per calcolare SMA
        function calculateSMA(data, period) {
            const sma = [];
            for (let i = 0; i < data.length; i++) {
                if (i < period - 1) {
                    sma.push(null);
                } else {
                    const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                    sma.push(sum / period);
                }
            }
            return sma;
        }
        
        // Funzione per calcolare EMA
        function calculateEMA(data, period) {
            const ema = [];
            const multiplier = 2 / (period + 1);
            
            for (let i = 0; i < data.length; i++) {
                if (i === 0) {
                    ema.push(data[i]);
                } else {
                    ema.push((data[i] - ema[i - 1]) * multiplier + ema[i - 1]);
                }
            }
            return ema;
        }
        
        // Funzione per classificare Bull/Bear
        // IMPORTANTE: Restituisce sempre BULL o BEAR, mai NEUTRAL
        function classificaBullBear(row, spy_vs_sma150, spy_vs_ema30, returns) {
            if (spy_vs_sma150 !== null && spy_vs_sma150 !== undefined) {
                if (spy_vs_sma150 > 0) return 'BULL';
                if (spy_vs_sma150 < 0) return 'BEAR';
                // Se esattamente 0, usa il valore precedente o default BULL
                return 'BULL'; // Forza BULL invece di NEUTRAL
            } else if (spy_vs_ema30 !== null && spy_vs_ema30 !== undefined) {
                return spy_vs_ema30 > 0 ? 'BULL' : 'BEAR';
            } else if (returns !== null && returns !== undefined) {
                return returns > 0 ? 'BULL' : 'BEAR';
            }
            return 'BULL'; // Default sempre BULL
        }
        
        // Funzione per raggruppare per anno
        function riepilogoAnnoPerAnno(data, spy_vs_sma150, closes) {
            const yearly = {};
            
            data.forEach((d, i) => {
                const year = new Date(d.date).getFullYear();
                if (!yearly[year]) {
                    yearly[year] = {
                        phases: [],
                        spy_vs_sma150_values: [],
                        startPrice: closes[i],
                        endPrice: closes[i],
                        startDate: d.date
                    };
                }
                
                const phase = classificaBullBear(d, spy_vs_sma150[i], null, null);
                yearly[year].phases.push(phase);
                if (spy_vs_sma150[i] !== null) {
                    yearly[year].spy_vs_sma150_values.push(spy_vs_sma150[i]);
                }
                yearly[year].endPrice = closes[i];
                yearly[year].endDate = d.date;
            });
            
            const summary = [];
            Object.keys(yearly).sort().forEach(year => {
                const y = yearly[year];
                const bullCount = y.phases.filter(p => p.includes('BULL')).length;
                const bullPercentage = (bullCount / y.phases.length) * 100;
                const dominantPhase = y.phases.filter(p => p.includes('BULL')).length > y.phases.length / 2 ? 'BULL' : 'BEAR';
                const avgSMA150 = y.spy_vs_sma150_values.length > 0 
                    ? y.spy_vs_sma150_values.reduce((a, b) => a + b, 0) / y.spy_vs_sma150_values.length 
                    : null;
                const changePct = ((y.endPrice - y.startPrice) / y.startPrice) * 100;
                
                summary.push({
                    year: parseInt(year),
                    dominantPhase,
                    avgSMA150,
                    bullPercentage,
                    startPrice: y.startPrice,
                    endPrice: y.endPrice,
                    changePct
                });
            });
            
            return summary;
        }
        
        // API Key Financial Modeling Prep
        const FMP_API_KEY = '59SIlu0tSse4YaQnAuRF1jS1KzgZWPSS';
        
        // Carica dati da Financial Modeling Prep STABLE API
        // NOTA: Gli endpoint legacy /api/v3/ sono stati dismessi
        // Usa gli endpoint /stable/ come da documentazione ufficiale
        async function caricaDatiSPY() {
            try {
                // Calcola date: ultimi 20 anni
                const endDate = new Date();
                const startDate = new Date();
                startDate.setFullYear(endDate.getFullYear() - 20);
                
                const fromDate = startDate.toISOString().split('T')[0];
                const toDate = endDate.toISOString().split('T')[0];
                
                // Endpoint FMP STABLE per dati storici giornalieri (non pi√π /api/v3/)
                const url = `https://financialmodelingprep.com/stable/historical-price-full?symbol=SPY&from=${fromDate}&to=${toDate}&apikey=${FMP_API_KEY}`;
                
                console.log('Caricamento dati da FMP API...');
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Verifica struttura risposta FMP STABLE API
                // Pu√≤ essere: { symbol: "SPY", historical: [...] } oppure array diretto
                let historicalData = [];
                
                if (Array.isArray(data)) {
                    // Se la risposta √® un array diretto
                    historicalData = data;
                } else if (data.historical && Array.isArray(data.historical)) {
                    // Se la risposta ha struttura { symbol: "SPY", historical: [...] }
                    historicalData = data.historical;
                } else if (data.symbol && Array.isArray(data)) {
                    // Altri formati possibili
                    historicalData = data;
                } else {
                    console.error('Formato risposta FMP non riconosciuto:', data);
                    throw new Error('Formato risposta API non valido');
                }
                
                if (historicalData.length === 0) {
                    throw new Error('Nessun dato storico disponibile');
                }
                
                // Formatta i dati FMP nel formato atteso
                // FMP formato: { date: "2024-01-15", close: 450.25, ... }
                const formattedData = historicalData
                    .map(item => ({
                        date: item.date || item.Date || item.timestamp,
                        close: item.close || item.Close || item.price
                    }))
                    .filter(d => d.close !== null && d.close !== undefined && d.date)
                    .sort((a, b) => new Date(a.date) - new Date(b.date)); // Ordina per data crescente
                
                console.log(`Dati caricati: ${formattedData.length} barre da ${formattedData[0].date} a ${formattedData[formattedData.length - 1].date}`);
                
                return formattedData;
            } catch (error) {
                console.error('Errore nel caricamento dati FMP:', error);
                console.log('Tentativo con endpoint alternativo (senza range date)...');
                
                // Fallback: prova senza range date (ultimi dati disponibili)
                try {
                    const urlFallback = `https://financialmodelingprep.com/stable/historical-price-full?symbol=SPY&apikey=${FMP_API_KEY}`;
                    const responseFallback = await fetch(urlFallback);
                    
                    if (responseFallback.ok) {
                        const dataFallback = await responseFallback.json();
                        
                        // Gestione formato risposta (come sopra)
                        let historicalDataFallback = [];
                        if (Array.isArray(dataFallback)) {
                            historicalDataFallback = dataFallback;
                        } else if (dataFallback.historical && Array.isArray(dataFallback.historical)) {
                            historicalDataFallback = dataFallback.historical;
                        }
                        
                        if (historicalDataFallback.length > 0) {
                            const formattedData = historicalDataFallback
                                .map(item => ({
                                    date: item.date || item.Date || item.timestamp,
                                    close: item.close || item.Close || item.price
                                }))
                                .filter(d => d.close !== null && d.close !== undefined && d.date)
                                .sort((a, b) => new Date(a.date) - new Date(b.date));
                            
                            console.log(`Dati caricati (fallback): ${formattedData.length} barre`);
                            return formattedData;
                        }
                    }
                } catch (fallbackError) {
                    console.error('Errore anche nel fallback:', fallbackError);
                }
                
                // Ultimo fallback: dati di esempio
                console.warn('Uso dati di esempio per demo');
                return generateSampleData();
            }
        }
        
        // Genera dati di esempio se l'API non funziona
        function generateSampleData() {
            const data = [];
            const startDate = new Date('2000-01-01');
            let price = 100;
            
            for (let i = 0; i < 6000; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);
                price += (Math.random() - 0.48) * 2; // Trend leggermente positivo
                data.push({
                    date: date.toISOString().split('T')[0],
                    close: Math.max(50, price)
                });
            }
            return data;
        }
        
        // Crea grafici
        function creaGrafici(data, vars, summary) {
            const { dates, closes, sma150, ema30, spy_vs_sma150 } = vars;
            
            // Grafico 1: Prezzo con background colorato
            // Classifica ogni punto come BULL o BEAR (niente NEUTRAL)
            // Calcola anche returns per fallback
            const returns = closes.map((close, i) => i > 0 ? (close - closes[i-1]) / closes[i-1] : null);
            
            const phases = closes.map((close, i) => {
                // Passa tutti i parametri per il fallback corretto
                const phase = classificaBullBear({}, spy_vs_sma150[i], vars.spy_vs_ema30[i], returns[i]);
                // Forza BULL o BEAR (niente NEUTRAL)
                return phase.includes('BULL') ? 'BULL' : 'BEAR';
            });
            
            // Debug: conta fasi e verifica valori spy_vs_sma150
            const bullCount = phases.filter(p => p === 'BULL').length;
            const bearCount = phases.filter(p => p === 'BEAR').length;
            const nullCount = spy_vs_sma150.filter(v => v === null || v === undefined).length;
            const positiveCount = spy_vs_sma150.filter(v => v !== null && v !== undefined && v > 0).length;
            const negativeCount = spy_vs_sma150.filter(v => v !== null && v !== undefined && v < 0).length;
            
            console.log(`Fasi totali: ${phases.length}, BULL: ${bullCount}, BEAR: ${bearCount}`);
            console.log(`spy_vs_sma150 - Null: ${nullCount}, Positivi: ${positiveCount}, Negativi: ${negativeCount}`);
            
            // Verifica che ci siano valori negativi
            if (negativeCount === 0) {
                console.warn('ATTENZIONE: Nessun valore negativo in spy_vs_sma150! Questo potrebbe indicare un problema nei dati.');
            }
            
            // Crea zone continue senza gap - ogni punto deve avere un colore
            // Usa approccio che crea zone continue senza spazi
            const bullZones = [];
            const bearZones = [];
            let currentZone = null;
            let zoneStartIdx = 0;
            
            // Itera attraverso tutte le fasi
            for (let i = 0; i < phases.length; i++) {
                const isBull = phases[i] === 'BULL';
                
                // Inizializza la prima zona
                if (currentZone === null) {
                    currentZone = isBull;
                    zoneStartIdx = i;
                }
                // Se cambia la fase, chiudi la zona precedente e inizia una nuova
                else if (currentZone !== isBull) {
                    // Chiudi la zona precedente - usa la data corrente come fine (senza gap)
                    if (currentZone) {
                        bullZones.push({ 
                            start: dates[zoneStartIdx], 
                            end: dates[i] // Usa la data corrente, non i-1
                        });
                    } else {
                        bearZones.push({ 
                            start: dates[zoneStartIdx], 
                            end: dates[i] // Usa la data corrente, non i-1
                        });
                    }
                    // Inizia nuova zona dalla stessa data (sovrapposizione per evitare gap)
                    currentZone = isBull;
                    zoneStartIdx = i;
                }
            }
            
            // Chiudi l'ultima zona (importante!) - deve andare fino all'ultima data
            if (currentZone !== null && zoneStartIdx < dates.length) {
                const lastDate = dates[dates.length - 1];
                if (currentZone) {
                    bullZones.push({ 
                        start: dates[zoneStartIdx], 
                        end: lastDate 
                    });
                } else {
                    bearZones.push({ 
                        start: dates[zoneStartIdx], 
                        end: lastDate 
                    });
                }
            }
            
            // Verifica che le zone coprano tutto il periodo
            const firstDate = dates[0];
            const lastDate = dates[dates.length - 1];
            const allZones = [...bullZones, ...bearZones].sort((a, b) => new Date(a.start) - new Date(b.start));
            
            if (allZones.length > 0) {
                const coverageStart = new Date(allZones[0].start);
                const coverageEnd = new Date(allZones[allZones.length - 1].end);
                console.log(`Copertura zone: da ${coverageStart} a ${coverageEnd}`);
                console.log(`Periodo dati: da ${firstDate} a ${lastDate}`);
                
                if (coverageStart > new Date(firstDate) || coverageEnd < new Date(lastDate)) {
                    console.warn('ATTENZIONE: Le zone non coprono tutto il periodo!');
                }
            }
            
            // Debug: verifica zone create
            console.log(`Zone BULL create: ${bullZones.length}, Zone BEAR create: ${bearZones.length}`);
            if (bearZones.length > 0) {
                console.log('Prima zona BEAR:', bearZones[0]);
            }
            if (bullZones.length > 0) {
                console.log('Prima zona BULL:', bullZones[0]);
            }
            
            // Verifica che ci siano zone BEAR - se no, potrebbe essere un problema nei dati
            if (bearZones.length === 0 && bearCount > 0) {
                console.warn('ATTENZIONE: Ci sono fasi BEAR ma nessuna zona BEAR creata!');
            }
            
            const trace1 = {
                x: dates,
                y: closes,
                type: 'scatter',
                mode: 'lines',
                name: 'SPY Close',
                line: { color: 'black', width: 2 }
            };
            
            const trace2 = {
                x: dates,
                y: sma150,
                type: 'scatter',
                mode: 'lines',
                name: 'SMA150',
                line: { color: 'blue', width: 2 }
            };
            
            const trace3 = {
                x: dates,
                y: ema30,
                type: 'scatter',
                mode: 'lines',
                name: 'EMA30',
                line: { color: 'orange', width: 1 }
            };
            
            // Crea shapes per coprire tutto il periodo senza gap
            const allShapes = [];
            
            // Aggiungi zone BULL (verde) - ordinate per data
            bullZones.sort((a, b) => new Date(a.start) - new Date(b.start)).forEach(zone => {
                allShapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: zone.start,
                    x1: zone.end,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(76, 175, 80, 0.45)', // Verde intensificato
                    line: { width: 0 },
                    layer: 'below',
                    opacity: 1
                });
            });
            
            // Aggiungi zone BEAR (rosso) - ordinate per data
            bearZones.sort((a, b) => new Date(a.start) - new Date(b.start)).forEach(zone => {
                allShapes.push({
                    type: 'rect',
                    xref: 'x',
                    yref: 'paper',
                    x0: zone.start,
                    x1: zone.end,
                    y0: 0,
                    y1: 1,
                    fillcolor: 'rgba(244, 67, 54, 0.45)', // Rosso intensificato
                    line: { width: 0 },
                    layer: 'below',
                    opacity: 1
                });
            });
            
            console.log(`Totale shapes create: ${allShapes.length} (${bullZones.length} BULL + ${bearZones.length} BEAR)`);
            
            Plotly.newPlot('chart1', [trace1, trace2, trace3], {
                title: 'SPY con Classificazione Bull/Bear',
                xaxis: { title: 'Data' },
                yaxis: { title: 'Prezzo ($)' },
                hovermode: 'x unified',
                shapes: allShapes,
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            });
            
            // Grafico 2: Percentuale SPY vs SMA150
            const trace4 = {
                x: dates,
                y: spy_vs_sma150.map(v => v !== null ? v * 100 : null),
                type: 'scatter',
                mode: 'lines',
                name: 'SPY vs SMA150 (%)',
                line: { color: 'purple', width: 2 },
                fill: 'tozeroy',
                fillcolor: 'rgba(128, 0, 128, 0.1)'
            };
            
            Plotly.newPlot('chart2', [trace4], {
                title: 'SPY vs SMA150 - Percentuale (Discriminante Principale)',
                xaxis: { title: 'Data' },
                yaxis: { title: 'Percentuale (%)' },
                shapes: [{
                    type: 'line',
                    xref: 'paper',
                    yref: 'y',
                    x0: 0,
                    x1: 1,
                    y0: 0,
                    y1: 0,
                    line: { color: 'black', width: 1, dash: 'dash' }
                }],
                annotations: [{
                    xref: 'paper',
                    yref: 'y',
                    x: 0.02,
                    y: 5,
                    text: 'BULL Zone',
                    showarrow: false,
                    bgcolor: 'rgba(76, 175, 80, 0.3)'
                }, {
                    xref: 'paper',
                    yref: 'y',
                    x: 0.02,
                    y: -5,
                    text: 'BEAR Zone',
                    showarrow: false,
                    bgcolor: 'rgba(244, 67, 54, 0.3)'
                }]
            });
            
            // Grafico 3: Riepilogo anno per anno
            const years = summary.map(s => s.year);
            const bullPercentages = summary.map(s => s.bullPercentage);
            const colors = bullPercentages.map(p => p > 50 ? 'rgba(76, 175, 80, 0.7)' : 'rgba(244, 67, 54, 0.7)');
            
            const trace5 = {
                x: years,
                y: bullPercentages,
                type: 'bar',
                name: '% Giorni BULL',
                marker: { color: colors }
            };
            
            Plotly.newPlot('chart3', [trace5], {
                title: 'Riepilogo Anno per Anno - % Giorni in Fase BULL',
                xaxis: { title: 'Anno' },
                yaxis: { title: '% Giorni BULL' },
                shapes: [{
                    type: 'line',
                    xref: 'paper',
                    yref: 'y',
                    x0: 0,
                    x1: 1,
                    y0: 50,
                    y1: 50,
                    line: { color: 'black', width: 1, dash: 'dash' }
                }]
            });
            
            // Tabella riepilogo
            const tableBody = document.getElementById('tableBody');
            summary.reverse().forEach(s => {
                const row = tableBody.insertRow();
                const cellClass = s.dominantPhase === 'BULL' ? 'bull' : 'bear';
                
                row.insertCell(0).textContent = s.year;
                row.insertCell(0).className = cellClass;
                
                const phaseCell = row.insertCell(1);
                phaseCell.textContent = s.dominantPhase;
                phaseCell.className = cellClass;
                
                const smaCell = row.insertCell(2);
                smaCell.textContent = s.avgSMA150 !== null ? (s.avgSMA150 * 100).toFixed(2) + '%' : 'N/A';
                
                const bullCell = row.insertCell(3);
                bullCell.textContent = s.bullPercentage.toFixed(1) + '%';
                bullCell.className = cellClass;
                
                row.insertCell(4).textContent = '$' + s.startPrice.toFixed(2);
                row.insertCell(5).textContent = '$' + s.endPrice.toFixed(2);
                
                const changeCell = row.insertCell(6);
                changeCell.textContent = (s.changePct >= 0 ? '+' : '') + s.changePct.toFixed(2) + '%';
                changeCell.className = cellClass;
            });
        }
        
        // Carica e visualizza dati
        async function init() {
            const loadingStatus = document.getElementById('loadingStatus');
            
            try {
                loadingStatus.textContent = 'Connessione a Financial Modeling Prep API...';
                const data = await caricaDatiSPY();
                
                loadingStatus.textContent = 'Calcolo variabili strutturali (EMA30, SMA150)...';
                const vars = calcolaVariabiliStrutturali(data);
                
                loadingStatus.textContent = 'Generazione riepilogo anno per anno...';
                const summary = riepilogoAnnoPerAnno(data, vars.spy_vs_sma150, vars.closes);
                
                loadingStatus.textContent = 'Creazione grafici interattivi...';
                document.getElementById('loading').style.display = 'none';
                document.getElementById('charts').style.display = 'block';
                
                creaGrafici(data, vars, summary);
                
                console.log('‚úÖ Grafici caricati con successo!');
            } catch (error) {
                loadingStatus.textContent = '‚ùå Errore: ' + error.message;
                console.error('Errore durante l\'inizializzazione:', error);
            }
        }
        
        // Avvia al caricamento
        init();
    </script>
</body>
</html>

//@version=6
// Market Detector (MD) — Phase Stratification Framework
// File Master: gestisce priorità, overlay e colore finale
// Q-Mentor Framework

indicator("Market Detector - Phase Stratification", shorttitle="MD", overlay=true, max_bars_back=500)

// ============================================================================
// FASE 0 — BASELINE (Bull/Bear Market)
// Sempre presente, sempre calcolato, sempre attivo in background
// Priorità: 1 (più bassa)
// Logica ufficiale Q-Mentor: SMA150 come discriminante principale
// ============================================================================
baselinePhase() =>
    // EMA30 (shock/crash/recovery)
    ema30 = ta.ema(close, 30)
    
    // SMA150 (regime primario) - DISCRIMINANTE PRINCIPALE
    sma150 = ta.sma(close, 150)
    
    // Calcolo posizioni relative (percentuali)
    spy_vs_ema30 = na(ema30) ? na : (close - ema30) / ema30
    spy_vs_sma150 = na(sma150) ? na : (close - sma150) / sma150
    
    // Returns per fallback
    returns = ta.change(close) / close[1]
    
    // Classificazione basata su priorità:
    // 1. SMA150 (discriminante principale)
    // 2. EMA30 (proxy durante warm-up period)
    // 3. Returns (fallback)
    // 4. Default: BULL (conservativo)
    
    isBull = false
    isBear = false
    
    if not na(spy_vs_sma150)
        // Classificazione principale basata su SMA150
        if spy_vs_sma150 > 0
            isBull := true
        else if spy_vs_sma150 < 0
            isBear := true
        // spy_vs_sma150 == 0 è NEUTRAL (caso raro)
    else if not na(spy_vs_ema30)
        // Proxy: usa EMA30 durante warm-up period (< 150 barre)
        if spy_vs_ema30 > 0
            isBull := true
        else
            isBear := true
    else if not na(returns)
        // Fallback: usa returns
        if returns > 0
            isBull := true
        else
            isBear := true
    else
        // Default conservativo: BULL
        isBull := true
    
    // Colori: Verde per Bull, Rosso per Bear
    phaseColor = isBull ? color.new(color.green, 80) : isBear ? color.new(color.red, 80) : color.new(color.gray, 90)
    
    [isBull, isBear, phaseColor]

// ============================================================================
// FASE 1 — LATERALITÀ / RANGE v2.1 FINAL (FROZEN)
// Priorità: 2 (sovrascrive Bull/Bear)
// Colore: Grigio
// VERSIONE CONGELATA - NON MODIFICARE SENZA APPROVAZIONE
// ============================================================================
// NOTA: Implementazione completa in phases/phase_1_lateralita.pine
// Questa è una versione semplificata per il file master
// Per implementazione completa v2.1, vedere phases/phase_1_lateralita.pine

lateralitaPhase() =>
    // Calcola metriche base
    ema30 = ta.ema(close, 30)
    sma150 = ta.sma(close, 150)
    
    if na(sma150)
        [false, na]
    else
        // Returns
        returns = ta.change(close) / close[1]
        abs_returns = math.abs(returns)
        
        // Core conditions
        net_move_20 = (close - close[20]) / close[20]
        sum_abs_moves_20 = math.sum(abs_returns, 20)
        trend_efficiency = math.abs(net_move_20) / sum_abs_moves_20
        trend_efficiency := na(trend_efficiency) ? 1.0 : trend_efficiency
        
        low_net_move = math.abs(net_move_20) < 0.025
        low_trend_eff = trend_efficiency < 0.30
        core_valid = low_net_move and low_trend_eff
        
        if not core_valid
            [false, na]
        else
            // Additional conditions
            spy_vs_sma150 = (close - sma150) / sma150
            sma150_proximity = math.abs(spy_vs_sma150)
            near_sma150 = sma150_proximity < 0.035
            
            spy_above_ema30 = close > ema30
            spy_cross_ema30 = spy_above_ema30 != spy_above_ema30[1] ? 1 : 0
            ema30_above_sma150 = ema30 > sma150
            ema30_cross_sma150 = ema30_above_sma150 != ema30_above_sma150[1] ? 1 : 0
            total_crosses_20 = math.sum(spy_cross_ema30, 20) + math.sum(ema30_cross_sma150, 20)
            high_crosses = total_crosses_20 >= 3
            
            high_low = high - low
            high_close = math.abs(high - close[1])
            low_close = math.abs(low - close[1])
            true_range = math.max(high_low, math.max(high_close, low_close))
            atr_20 = ta.sma(true_range, 20)
            range_20 = ta.highest(high, 20) - ta.lowest(low, 20)
            range_atr_ratio = range_20 / atr_20
            low_range_atr = range_atr_ratio < 5.0
            
            additional_count = (near_sma150 ? 1 : 0) + (high_crosses ? 1 : 0) + (low_range_atr ? 1 : 0)
            additional_valid = additional_count >= 2
            
            isLateral = core_valid and additional_valid
            phaseColor = isLateral ? color.new(color.gray, 60) : na
            [isLateral, phaseColor]

// ============================================================================
// FASE 2 — CRASH
// Priorità: 6
// Colore: Giallo
// ============================================================================
crashPhase() =>
    changePercent = ((close - close[1]) / close[1]) * 100
    changePercent2 = ((close[1] - close[2]) / close[2]) * 100
    isCrash = changePercent < -5.0 or (changePercent < -3.0 and changePercent2 < -4.0)
    phaseColor = isCrash ? color.new(color.yellow, 60) : na
    [isCrash, phaseColor]

// ============================================================================
// FASE 3 — CAPITULATION
// Priorità: 7 (MASSIMA)
// Colore: Viola
// ============================================================================
capitulationPhase() =>
    volumeSpike = volume > ta.sma(volume, 20) * 2.0
    violentDrop = ((close - close[1]) / close[1]) * 100 < -6.0
    isCapitulation = volumeSpike and violentDrop
    phaseColor = isCapitulation ? color.new(color.purple, 50) : na
    [isCapitulation, phaseColor]

// ============================================================================
// FASE 4 — RECOVERY
// Priorità: 4
// Colore: Azzurro
// ============================================================================
recoveryPhase() =>
    recentLow = ta.lowest(low, 10)
    bounceFromLow = close > recentLow * 1.02
    sma50 = ta.sma(close, 50)
    isRecovery = bounceFromLow and close < sma50
    phaseColor = isRecovery ? color.new(color.aqua, 70) : na
    [isRecovery, phaseColor]

// ============================================================================
// FASE 5 — ACCUMULAZIONE
// Priorità: 5
// Colore: Blu
// ============================================================================
accumulazionePhase() =>
    sma20 = ta.sma(close, 20)
    sma50 = ta.sma(close, 50)
    isAccumulation = close > sma20 and close < sma50 * 1.05 and ta.sma(volume, 10) > ta.sma(volume, 30)
    phaseColor = isAccumulation ? color.new(color.blue, 60) : na
    [isAccumulation, phaseColor]

// ============================================================================
// FASE 6 — DISTRIBUZIONE
// Priorità: 3
// Colore: Arancione
// ============================================================================
distribuzionePhase() =>
    sma20 = ta.sma(close, 20)
    sma50 = ta.sma(close, 50)
    isBull = close > sma20 and sma20 > sma50
    rsi = ta.rsi(close, 14)
    isDistribution = isBull and rsi > 70 and ta.mom(close, 10) < 0
    phaseColor = isDistribution ? color.new(color.orange, 65) : na
    [isDistribution, phaseColor]

// ============================================================================
// GESTIONE PRIORITÀ E OVERLAY
// Gerarchia: Capitulation (7) > Crash (6) > Accumulazione (5) > Recovery (4) 
//           > Distribuzione (3) > Lateralità (2) > Baseline (1)
// ============================================================================

// Calcolo di tutte le fasi
[isBull, isBear, baselineColor] = baselinePhase()
[isLateral, lateralColor] = lateralitaPhase()
[isCrash, crashColor] = crashPhase()
[isCapitulation, capitulationColor] = capitulationPhase()
[isRecovery, recoveryColor] = recoveryPhase()
[isAccumulation, accumulationColor] = accumulazionePhase()
[isDistribution, distributionColor] = distribuzionePhase()

// ============================================================================
// DETERMINAZIONE FASE FINALE PER DECISION LAYER
// IMPORTANTE: La fase determinata qui è quella comunicata al Decision Layer
// Priorità: Capitulation (7) > Crash (6) > Accumulazione (5) > Recovery (4) 
//           > Distribuzione (3) > Lateralità (2) > Baseline (1)
// ============================================================================

// Determina fase finale (per Decision Layer) e colore (per visualizzazione)
finalColor = na
md_phase = ""  // Fase comunicata al Decision Layer

// Applicazione priorità (dalla più alta alla più bassa)
// NOTA: Quando LATERAL è attiva, viene comunicata "LATERAL" al Decision Layer,
//       NON Bull o Bear, anche se Bull/Bear sono tecnicamente attive in background
if not na(capitulationColor)
    finalColor := capitulationColor
    md_phase := "CAPITULATION"
else if not na(crashColor)
    finalColor := crashColor
    md_phase := "CRASH"
else if not na(accumulationColor)
    finalColor := accumulationColor
    md_phase := "ACCUMULATION"
else if not na(recoveryColor)
    finalColor := recoveryColor
    md_phase := "RECOVERY"
else if not na(distributionColor)
    finalColor := distributionColor
    md_phase := "DISTRIBUTION"
else if not na(lateralColor)
    // LATERAL ha precedenza su Bull/Bear - questa è la fase comunicata al Decision Layer
    finalColor := lateralColor
    md_phase := "LATERAL"
else
    // Baseline (Bull/Bear) - solo se nessuna altra fase è attiva
    finalColor := baselineColor
    md_phase := isBull ? "BULL" : "BEAR"

// Applicazione colore di background
bgcolor(finalColor, title="Market Phase Background")

// Labels opzionali per debug (commentare se non necessario)
// var label debugLabel = na
// if barstate.islast
//     label.delete(debugLabel)
//     phaseName = not na(capitulationColor) ? "Capitulation" : 
//                 not na(crashColor) ? "Crash" : 
//                 not na(accumulationColor) ? "Accumulation" : 
//                 not na(recoveryColor) ? "Recovery" : 
//                 not na(distributionColor) ? "Distribution" : 
//                 not na(lateralColor) ? "Lateral" : 
//                 (isBull ? "Bull" : "Bear")
//     debugLabel := label.new(bar_index, high, phaseName, style=label.style_label_down, color=finalColor, textcolor=color.white, size=size.small)

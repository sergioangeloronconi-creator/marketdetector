//@version=6
// Market Detector (MD) â€” Phase Stratification Framework
// File Master: gestisce gerarchia costituzionale, overlay e colore finale
// Q-Mentor Framework
// VERSIONE: 1.0 FINAL - CONGELATA
// Gerarchia Costituzionale: Vedi MANIFESTO_GERARCHIA.md (FROZEN)

indicator("Market Detector - Phase Stratification", shorttitle="MD", overlay=true, max_bars_back=500)

// ============================================================================
// FASE 0 â€” BASELINE (Bull/Bear Market)
// Sempre presente, sempre calcolato, sempre attivo in background
// PrioritÃ : 1 (piÃ¹ bassa)
// Logica ufficiale Q-Mentor: SMA150 come discriminante principale
// ============================================================================
baselinePhase() =>
    // EMA30 (shock/crash/recovery)
    ema30 = ta.ema(close, 30)
    
    // SMA150 (regime primario) - DISCRIMINANTE PRINCIPALE
    sma150 = ta.sma(close, 150)
    
    // Calcolo posizioni relative (percentuali)
    spy_vs_ema30 = na(ema30) ? na : (close - ema30) / ema30
    spy_vs_sma150 = na(sma150) ? na : (close - sma150) / sma150
    
    // Returns per fallback
    returns = ta.change(close) / close[1]
    
    // Classificazione basata su prioritÃ :
    // 1. SMA150 (discriminante principale)
    // 2. EMA30 (proxy durante warm-up period)
    // 3. Returns (fallback)
    // 4. Default: BULL (conservativo)
    
    isBull = false
    isBear = false
    
    if not na(spy_vs_sma150)
        // Classificazione principale basata su SMA150
        if spy_vs_sma150 > 0
            isBull := true
        else if spy_vs_sma150 < 0
            isBear := true
        // spy_vs_sma150 == 0 Ã¨ NEUTRAL (caso raro)
    else if not na(spy_vs_ema30)
        // Proxy: usa EMA30 durante warm-up period (< 150 barre)
        if spy_vs_ema30 > 0
            isBull := true
        else
            isBear := true
    else if not na(returns)
        // Fallback: usa returns
        if returns > 0
            isBull := true
        else
            isBear := true
    else
        // Default conservativo: BULL
        isBull := true
    
    // Colori: Verde per Bull, Rosso per Bear
    phaseColor = isBull ? color.new(color.green, 80) : isBear ? color.new(color.red, 80) : color.new(color.gray, 90)
    
    [isBull, isBear, phaseColor]

// ============================================================================
// FASE 1 â€” LATERALITÃ€ / RANGE v2.1 FINAL (FROZEN)
// PrioritÃ : 2 (sovrascrive Bull/Bear)
// Colore: Grigio
// VERSIONE CONGELATA - NON MODIFICARE SENZA APPROVAZIONE
// ============================================================================
// NOTA: Implementazione completa in phases/phase_1_lateralita.pine
// Questa Ã¨ una versione semplificata per il file master
// Per implementazione completa v2.1, vedere phases/phase_1_lateralita.pine

lateralitaPhase() =>
    // Calcola metriche base
    ema30 = ta.ema(close, 30)
    sma150 = ta.sma(close, 150)
    
    if na(sma150)
        [false, na]
    else
        // Returns
        returns = ta.change(close) / close[1]
        abs_returns = math.abs(returns)
        
        // Core conditions
        net_move_20 = (close - close[20]) / close[20]
        sum_abs_moves_20 = math.sum(abs_returns, 20)
        trend_efficiency = math.abs(net_move_20) / sum_abs_moves_20
        trend_efficiency := na(trend_efficiency) ? 1.0 : trend_efficiency
        
        low_net_move = math.abs(net_move_20) < 0.025
        low_trend_eff = trend_efficiency < 0.30
        core_valid = low_net_move and low_trend_eff
        
        if not core_valid
            [false, na]
        else
            // Additional conditions
            spy_vs_sma150 = (close - sma150) / sma150
            sma150_proximity = math.abs(spy_vs_sma150)
            near_sma150 = sma150_proximity < 0.035
            
            spy_above_ema30 = close > ema30
            spy_cross_ema30 = spy_above_ema30 != spy_above_ema30[1] ? 1 : 0
            ema30_above_sma150 = ema30 > sma150
            ema30_cross_sma150 = ema30_above_sma150 != ema30_above_sma150[1] ? 1 : 0
            total_crosses_20 = math.sum(spy_cross_ema30, 20) + math.sum(ema30_cross_sma150, 20)
            high_crosses = total_crosses_20 >= 3
            
            high_low = high - low
            high_close = math.abs(high - close[1])
            low_close = math.abs(low - close[1])
            true_range = math.max(high_low, math.max(high_close, low_close))
            atr_20 = ta.sma(true_range, 20)
            range_20 = ta.highest(high, 20) - ta.lowest(low, 20)
            range_atr_ratio = range_20 / atr_20
            low_range_atr = range_atr_ratio < 5.0
            
            additional_count = (near_sma150 ? 1 : 0) + (high_crosses ? 1 : 0) + (low_range_atr ? 1 : 0)
            additional_valid = additional_count >= 2
            
            isLateral = core_valid and additional_valid
            phaseColor = isLateral ? color.new(color.gray, 60) : na
            [isLateral, phaseColor]

// ============================================================================
// FASE 2 â€” CRASH
// PrioritÃ : 6
// Colore: Giallo
// ============================================================================
crashPhase() =>
    changePercent = ((close - close[1]) / close[1]) * 100
    changePercent2 = ((close[1] - close[2]) / close[2]) * 100
    isCrash = changePercent < -5.0 or (changePercent < -3.0 and changePercent2 < -4.0)
    phaseColor = isCrash ? color.new(color.yellow, 60) : na
    [isCrash, phaseColor]

// ============================================================================
// FASE 3 â€” CAPITULATION
// PrioritÃ : 7 (MASSIMA)
// Colore: Viola
// ============================================================================
capitulationPhase() =>
    volumeSpike = volume > ta.sma(volume, 20) * 2.0
    violentDrop = ((close - close[1]) / close[1]) * 100 < -6.0
    isCapitulation = volumeSpike and violentDrop
    phaseColor = isCapitulation ? color.new(color.purple, 50) : na
    [isCapitulation, phaseColor]

// ============================================================================
// FASE 4 â€” RECOVERY
// PrioritÃ : 4
// Colore: Azzurro
// ============================================================================
recoveryPhase() =>
    recentLow = ta.lowest(low, 10)
    bounceFromLow = close > recentLow * 1.02
    sma50 = ta.sma(close, 50)
    isRecovery = bounceFromLow and close < sma50
    phaseColor = isRecovery ? color.new(color.aqua, 70) : na
    [isRecovery, phaseColor]

// ============================================================================
// FASE 5 â€” ACCUMULAZIONE
// PrioritÃ : 5
// Colore: Blu
// ============================================================================
accumulazionePhase() =>
    sma20 = ta.sma(close, 20)
    sma50 = ta.sma(close, 50)
    isAccumulation = close > sma20 and close < sma50 * 1.05 and ta.sma(volume, 10) > ta.sma(volume, 30)
    phaseColor = isAccumulation ? color.new(color.blue, 60) : na
    [isAccumulation, phaseColor]

// ============================================================================
// FASE 6 â€” DISTRIBUZIONE
// PrioritÃ : 3
// Colore: Arancione
// ============================================================================
distribuzionePhase() =>
    sma20 = ta.sma(close, 20)
    sma50 = ta.sma(close, 50)
    isBull = close > sma20 and sma20 > sma50
    rsi = ta.rsi(close, 14)
    isDistribution = isBull and rsi > 70 and ta.mom(close, 10) < 0
    phaseColor = isDistribution ? color.new(color.orange, 65) : na
    [isDistribution, phaseColor]

// ============================================================================
// GERARCHIA COSTITUZIONALE - Vedi MANIFESTO_GERARCHIA.md (FROZEN)
// LIVELLO 0: Eventi Sistemici (CRASH, CAPITULATION) - AutoritÃ  assoluta
// LIVELLO 1: Regime Strutturale (BULL, BEAR, LATERAL, RECOVERY) - Mutualmente esclusivi
// LIVELLO 2: Eventi Locali di Stress (LoCE, Capitulation locale)
// LIVELLO 3: Processi di Rischio (ACCUMULATION, DISTRIBUTION) - NON sono fasi
// LIVELLO 4: Rotazione Settoriale
// LIVELLO 5: Qualificatori
// ============================================================================

// Calcolo di tutte le fasi
[isBull, isBear, baselineColor] = baselinePhase()
[isLateral, lateralColor] = lateralitaPhase()
[isCrash, crashColor] = crashPhase()
[isCapitulation, capitulationColor] = capitulationPhase()
[isRecovery, recoveryColor] = recoveryPhase()
[isAccumulation, accumulationColor] = accumulazionePhase()
[isDistribution, distributionColor] = distribuzionePhase()

// ============================================================================
// COMUNICAZIONE MULTILIVELLO AL DECISION LAYER
// Gerarchia Costituzionale - Vedi: MANIFESTO_GERARCHIA.md
// Ordine: LIVELLO 0 â†’ LIVELLO 1 â†’ LIVELLO 2 â†’ LIVELLO 3 â†’ LIVELLO 4 â†’ Transition
// ============================================================================

// ============================================================================
// ðŸ”´ LIVELLO 0 â€” EVENTI SISTEMICI (AUTORITÃ€ ASSOLUTA)
// ============================================================================

md_level_0_event = "NONE"  // CRASH, CAPITULATION, NONE

// Se LIVELLO 0 Ã¨ attivo â†’ tutti gli altri livelli sono informativi ma non rilevanti
if not na(capitulationColor)
    md_level_0_event := "CAPITULATION"
else if not na(crashColor)
    md_level_0_event := "CRASH"

// ============================================================================
// ðŸŸ  LIVELLO 1 â€” REGIME STRUTTURALE (SPINA DORSALE)
// Mutualmente esclusivi: solo uno stato puÃ² essere attivo alla volta
// ============================================================================

md_phase = ""  // Regime strutturale: BULL, BEAR, LATERAL, RECOVERY

// Determina regime strutturale (solo se LIVELLO 0 non Ã¨ attivo)
if md_level_0_event != "NONE"
    // LIVELLO 0 ha autoritÃ  assoluta - regime Ã¨ informativo ma non rilevante
    md_phase := isBull ? "BULL" : "BEAR"  // Informativo
else
    // LIVELLO 1: Regime strutturale (mutualmente esclusivi)
    // RECOVERY: Fase strutturale congelata (concetto) - Vedi FASE_RECOVERY_FROZEN.md
    if not na(recoveryColor)
        md_phase := "RECOVERY"
    else if not na(lateralColor)
        // LATERAL ha precedenza su Bull/Bear
        md_phase := "LATERAL"
    else
        // Baseline (Bull/Bear)
        md_phase := isBull ? "BULL" : "BEAR"

// ============================================================================
// ðŸŸ¡ LIVELLO 2 â€” EVENTI LOCALI DI STRESS
// ============================================================================

md_level_2_event = "NONE"  // LoCE, LOCAL_CAPITULATION, NONE

// TODO: Implementare quando fase LoCE sarÃ  sviluppata
// Possono apparire in Bull, Bear o Lateral
// Non cambiano il regime

// ============================================================================
// ðŸŸ¢ LIVELLO 3 â€” PROCESSI DI RISCHIO SISTEMICO
// âš ï¸ IMPORTANTE: Accumulation/Distribution NON sono fasi, sono PROCESSI
// ============================================================================

md_process = "NONE"  // Processo latente: DISTRIBUTION, ACCUMULATION, NONE

// Determina processo latente (puÃ² coesistere con LIVELLO 1)
// NOTA: md_process puÃ² coesistere con md_phase (non si escludono)
if not na(distributionColor)
    md_process := "DISTRIBUTION"
else if not na(accumulationColor)
    md_process := "ACCUMULATION"
// else rimane "NONE"

// ============================================================================
// ðŸ”µ LIVELLO 4 â€” ROTAZIONE SETTORIALE
// ============================================================================

sector_rotation = false  // Rotazione settoriale in atto
sector_rotation_type = "none"  // Tipo: "ciclica", "difensiva", "growth", "none"

// TODO: Implementare quando dati settoriali disponibili
// La rotazione NON implica nÃ© accumulazione nÃ© distribuzione

// ============================================================================
// âšª LIVELLO 5 â€” QUALIFICATORI
// ============================================================================

// TODO: Implementare qualificatori (intensitÃ , persistenza, confidence)

// ============================================================================
// STATO DI TRANSIZIONE (DERIVATO)
// md_transition = TRUE se LIVELLO 3 â‰  NONE e incoerente con LIVELLO 1
// ============================================================================

md_transition = false  // Transizione tra fasi in atto

// Transizione derivata: Bull + Distribution â†’ Transition
//                      Bear + Accumulation â†’ Transition
if md_process != "NONE" and md_phase != ""
    // Bull + Distribution â†’ Transition
    if md_phase == "BULL" and md_process == "DISTRIBUTION"
        md_transition := true
    // Bear + Accumulation â†’ Transition
    else if md_phase == "BEAR" and md_process == "ACCUMULATION"
        md_transition := true

// ============================================================================
// DETERMINAZIONE COLORE FINALE (per visualizzazione)
// ============================================================================

finalColor = na

// LIVELLO 0 ha autoritÃ  assoluta (sovrascrive tutto visivamente)
if md_level_0_event == "CAPITULATION"
    finalColor := capitulationColor
else if md_level_0_event == "CRASH"
    finalColor := crashColor
// LIVELLO 1: Regime strutturale
else if md_phase == "RECOVERY"
    finalColor := recoveryColor
else if md_phase == "LATERAL"
    finalColor := lateralColor
else if md_phase == "BULL"
    finalColor := baselineColor  // Verde
else if md_phase == "BEAR"
    finalColor := baselineColor  // Rosso

// ============================================================================
// OUTPUT MULTILIVELLO COMPLETO PER DECISION LAYER
// ============================================================================
// 
// Struttura output (VINCOLANTE):
// {
//   "md_level_0_event": "CRASH|CAPITULATION|NONE",      // LIVELLO 0
//   "md_phase": "BULL|BEAR|LATERAL|RECOVERY",          // LIVELLO 1
//   "md_level_2_event": "LoCE|LOCAL_CAPITULATION|NONE", // LIVELLO 2
//   "md_process": "ACCUMULATION|DISTRIBUTION|NONE",    // LIVELLO 3
//   "sector_rotation": true|false,                      // LIVELLO 4
//   "sector_rotation_type": "ciclica|difensiva|none",   // LIVELLO 4
//   "md_transition": true|false                         // Derivato
// }
//
// Ordine di comunicazione: LIVELLO 0 â†’ LIVELLO 1 â†’ LIVELLO 2 â†’ LIVELLO 3 â†’ LIVELLO 4 â†’ Transition
// Vedi: MANIFESTO_GERARCHIA.md per gerarchia costituzionale completa

// Applicazione colore di background
bgcolor(finalColor, title="Market Phase Background")

// Labels opzionali per debug (commentare se non necessario)
// var label debugLabel = na
// if barstate.islast
//     label.delete(debugLabel)
//     phaseName = not na(capitulationColor) ? "Capitulation" : 
//                 not na(crashColor) ? "Crash" : 
//                 not na(accumulationColor) ? "Accumulation" : 
//                 not na(recoveryColor) ? "Recovery" : 
//                 not na(distributionColor) ? "Distribution" : 
//                 not na(lateralColor) ? "Lateral" : 
//                 (isBull ? "Bull" : "Bear")
//     debugLabel := label.new(bar_index, high, phaseName, style=label.style_label_down, color=finalColor, textcolor=color.white, size=size.small)
